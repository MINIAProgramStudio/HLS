\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Проєктування високонавантаженних систем. Лабораторна 1, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\graphicspath{ {./img/} }

\def\code#1{\texttt{#1}}
\begin{document}
\maketitle
\section{Завдання лабораторної роботи}
\subsection{Загальне}
Порівняти throughput (пропускна здатність) Веб-застосунку в залежності від навантаження та способу зберігання даних (в пам'яті та БД).
Створити Веб-застосунок який містить два ендпоінта (приймає два запити)

- /inc - інкрементує внутрішній каунтер

- /count - повертає значення каунтера

Наприклад, якщо 

\code{http://localhost:8080/inc} був викликаний 10 разів, то

\code{http://localhost:8080/count} має повернути 10.

Наступним кроком необхідно створити HTTP-клієнта, який зможе робити задану кількість викликів до Веб-застосунку, а також заміряти час витрачений на здійснення цих викликів.

У якості клієнта може бути утиліта curl (чи будь-яка інша утиліта командного рядка), скрипт на Python (чи будь-якії іншій мові програмування)

У подальших завданнях треба буде в залежності від одночасної кількості клієнтів визначати яку кількість запитів в секунду обробляє Веб-застосунок. Це обраховується як - count/time, де time - кількість часу (секунд) яка була сумарна витрачена на здійснення всіх запитів

\subsection{Частина 1}
Завдання:
\begin{enumerate}
    \item Один клієнт робить послідовно 10К викликів, кінцеве значення count = 10K - порахувати кількість запитів в секунду
    \item Два клієнта роблять одночасно по 10К викликів кожен, кінцеве значення count = 20K - порахувати кількість запитів в секунду
    \item 5 клієнтів роблять одночасно по 10К викликів кожен, кінцеве значення count = 50K - порахувати кількість запитів в секунду
    \item 10 клієнтів роблять одночасно по 10К викликів кожен, кінцеве значення count = 100K - порахувати кількість запитів в секунду
\end{enumerate}
Будьте уважні:
\begin{itemize}
    \item Веб-застосунок має підртимувати багатопоточність (це не завжди так за замовченням)
    \item Клієнти мають запускатись паралельно та одночасно генерувати запити
    \item Каунтер на вашому Веб-застосунку має бути потоко-безпечним та забезпечувати відсутність lost-update
\end{itemize}

\subsection{Частина 2}
Перенести каунтер з оперативної пам'яті до БД (наприклад PostgreSQL).
Тепер при кожному виклику /inc має інкрементуватись значення, яке зберігається у таблиці БД.
При виклику /count кінцеве значення має зчитуватись з БД.

Зробить аналогічні вимірювання для 1) - 4) з попередної частини.

Порівняйте та проаналізуйте результати.

\subsection{Вимоги до звіту та реалізації}
\begin{itemize}
    \item Мова реалізації будь-яка
    \item Має бути надано код програми/скрипта та результати виконання
\end{itemize}



\section{Реалізація лічильника в оперативній пам'яті}
\subsection{Сервер}
Сервер реалізовано на \code{Python} з використанням модуля \code{Flask}.

Оголошуються застосунок, лічильник та семафор (lock). 
Визначаються ендпоінти які через семафор змінюють або читають лічильник.

Сам застосунок є багатопотоковим, але однопроцессовим.

Повний код застосунку:
\begin{lstlisting}[language=Python]
from flask import Flask
import threading

app = Flask(__name__)

counter = [0]
lock = threading.Lock()

@app.route("/inc")
def inc():
    global counter
    with lock:
        counter[0] += 1

@app.route("/count")
def count():
    with lock:
        return str(counter[0])
\end{lstlisting}

Повний код сервера:
\begin{lstlisting}[language=Python]
from waitress import serve
from app import app

if __name__ == "__main__":
    serve(app, host="0.0.0.0", port=8080, threads=5)
\end{lstlisting}

\subsection{Клієнт}
Клієнт містить дві функції -- \code{worker} та \code{main}.
\code{worker} послідовно робить вказану кількість запитів і зупиняється.
\code{main} запам'ятовує час початку, 
запускає необхідну кількість потоків які виконують \code{worker},
очікує на завершення цих потоків,
робить запит на ендпоінт \code{/count},
і виводить в консоль отриманий \code{count} та \code{count/time}

Повний код:
\begin{lstlisting}[language=Python]
import requests
import threading
import time

SERVER = "http://127.0.0.1:8080"
CALLS_PER_CLIENT = 10_000
NUM_CLIENTS = 1

def worker(client_id):
    for i in range(CALLS_PER_CLIENT):
        try:
            requests.get(f"{SERVER}/inc")
        except requests.exceptions.RequestException:
            pass

def main():
    print(f"Starting {NUM_CLIENTS} clients x {CALLS_PER_CLIENT} calls each...")
    start = time.time()

    threads = []
    for i in range(NUM_CLIENTS):
        t = threading.Thread(target=worker, args=(i,))
        t.start()
        threads.append(t)

    for t in threads:
        t.join()

    end = time.time()
    elapsed = end - start

    try:
        final_count = int(requests.get(f"{SERVER}/count").text)
    except:
        final_count = -1

    total_calls = CALLS_PER_CLIENT * NUM_CLIENTS
    throughput = total_calls / elapsed

    print(f"Final count: {final_count}")
    print(f"Total time:  {elapsed:.2f} s")
    print(f"Throughput:  {throughput:.2f} requests/sec")

if __name__ == "__main__":
    main()
    input()
\end{lstlisting}

\section{Запити з лічильником в оперативній пам'яті}
Приклад результату роботи \code{client.py}:
\begin{verbatim}
Starting 1 clients x 10000 calls each...
Final count: 10000
Total time:  19.81 s
Throughput:  504.72 requests/sec
\end{verbatim}

Результати роботи системи:
\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
 Клієнтів & Всього запитів & Лічильник & Час (s) & count/time (req/s)\\ 
 \hline
 1 & 10 000 & 10 000 & 11.18 & 894.58\\ 
 \hline
 2 & 20 000 & 20 000 & 15.88 & 1259.47\\
 \hline
 5 & 50 000 & 50 000 & 34.70 & 1440.96\\
 \hline
 10 & 100 000 & 98 010 & 209.64 & 477.00\\
 \hline
\end{tabular}
\end{center}


\end{document}