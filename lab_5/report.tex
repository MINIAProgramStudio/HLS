\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\title{Проєктування високонавантаженних систем. Лабораторна 5, звіт}
\author{Михайло Голуб}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=t,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

\lstdefinelanguage{YAML}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{blue}\bfseries,
  basicstyle=\ttfamily,
  sensitive=false,
  comment=[l]{\#},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  moredelim=[l]{:},
  morestring=[b]',
  morestring=[b]"
}
\graphicspath{ {./img/} }

\def\code#1{\texttt{#1}}
\begin{document}
\maketitle
\section{Завдання лабораторної роботи}
\subsection{Частина 1. Робота зі структурами даних у Cassandra}
\begin{enumerate}
    \item Ознайомитись з особливістю моделювання даних у Cassandra;
    \item Створити \code{keyspace} з найпростішою стратегією реплікації;
    \item Створити дві таблиці: \code{items} та \code{orders};
    \item Таблиця \code{items} містить різноманітні товари (тобто у яких різний набір властивостей).
        Для набору властивостей товару виберіть базові характеристики однакові для всіх товарів (\code{name, category, price, producer,} ...),
        а для властивостей які відрізняються використовуйте тип map (створивши індекс для можливості пошуку по її вмісту)
        Необхідно, щоб пошук швидко працював для категорії (\code{category}) товарів. 
        Ця вимога має бути врахована при створенні ключа для таблиці (тобто, \code{category} має бути \code{partition key});
    \item Наповнити таблицю тестовими данними;
    \item Написати запит, який показує структуру створеної таблиці (команда \code{DESCRIBE});
    \item Написати запит, який виводить усі товари в певній категорії відсортовані за ціною;
    \item Напишіть запити, які вибирають товари за різними критеріями в межах певної категорії 
        (тут де треба замість індексу використайте Matirialized view): назва, ціна (в проміжку), ціна та виробник
    \item Створіть таблицю orders в якій міститься ім'я замовника і інформація про замовлення: 
        перелік id-товарів у замовленні, вартість замовлення, дата замовлення, ... 
        Для кожного замовника повинна бути можливість швидко шукати його замовлення і виконувати по них запити. 
        Ця вимога має бути врахована при створенні ключа для таблиці (аналогічно як для items);
    \item Напишіть запит, який показує структуру створеної таблиці (команда DESCRIBE);
    \item Для замовника виведіть всі його замовлення відсортовані за часом коли вони були зроблені;
    \item Для кожного замовників підрахуйте загальну суму на яку були зроблені усі його замовлення;
    \item Для кожного замовлення виведіть час коли його ціна були занесена в базу (SELECT WRITETIME);
\end{enumerate}
\textbf{!!! У запитах заборонено використовувати ALLOW FILTERING !!!}

\subsection{Частина 2. Налаштування реплікації у Cassandra}

\begin{enumerate}
    \item Сконфігурувати кластер з 3-х нод;
    \item Перевірити правильність конфігурації за допомогою \code{nodetool status};
    \item Використовуючи \code{cqlsh}, створити три \code{keyspace} 
        з \code{replication factor} 1, 2, 3 з \code{SimpleStrategy};
    \item В кожному з кейспейсів створити прості таблиці;
    \item Спробувати писати і читати в ці таблиці підключаючись до різних нод через \code{cqlsh};
    \item Вставте дані в створені таблиці і подивіться на їх розподіл по вузлах кластера окремо;
        для кожного з кейспейсів (команда \code{nodetool status}) -- має бути видно відсоток даних який зберігається на ноді;
    \item Для якогось запису з кожного з кейспейсу виведіть ноди на яких зберігаються дані -- 
        має бути видно ip-адреси вузлів на яких зберігається даний рядок;
    \item Відключити одну з нод. Для кожного з кейспейсів перевірити з якими рівнями consistency можемо читати та писати:
        для \code{replication factor} 1 -- \code{CONSISTENCY ONE}, для 2 -- \code{CONSISTENCY ONE/TWO}, для 3 -- \code{CONSISTENCY ONE/TWO/THREE};
    \item Зробити так щоб три ноди працювали, але не бачили одна одну по мережі (заблокувати чи відключити зв'язок між ними);
    \item Для кейспейсу з replication factor 3 задати рівень consistency рівним 1. 
        Виконати по черзі запис значення з однаковим primary key, 
        але різними іншими значенням окремо на кожну з нод (тобто створіть конфлікт);
    \item Відновити зв'язок між нодами, перевірити що вони знову об'єднались у кластер.
        Визначити яким чином був вирішений конфлікт даних та яке значення було прийнято кластером та за яким принципом.
\end{enumerate}

\subsection{Частина 3. Аналіз продуктивності та перевірка цілісності}
Аналогічно попереднім завданням, необхідно, для кластеру налаштованому у попередній частині, 
створити таблицю з каунтером лайків. 
Далі з 10 окремих клієнтів одночасно запустити інкерементацію каунтеру лайків 
по 10\_000 на кожного клієнта з різними опціями взаємодії з Cassandra.
Таблиця має бути створена у Keyspace з replication factor 3.
Для створення каунтеру використовуйте спеціальний тип колонки -- 
counter (цей тип буде підтримувати операції increment/decrement in-place):
\begin{itemize}
    \item Вказавши у параметрах запиту \code{Consistency Level One} 
        (це буде означати, що запис відбувається синхронно тільки на одну ноду), 
        запустіть 10 клієнтів з інкрементом по 10\_000 на кожному з них. 
        Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному -- 100К
    \item Вказавши у параметрах запиту \code{Consistency Level QUORUM} 
        (це буде означати, що запис відбувається синхронно на більшість нод), 
        запустіть 10 клієнтів  з інкрементом по 10\_000 на кожному з них. 
        Виміряйте час виконання та перевірте чи кінцеве значення буде дорівнювати очікуваному -- 100К
\end{itemize}

\subsection{Вимоги до оформлення протоколу}
Завдання здається особисто без протоколу, або надсилається протокол який має містити:
\begin{itemize}
    \item команди та результати їх виконання у вигляді скріншотів
    \item аналіз отриманих результатів
\end{itemize}

\section{Хід роботи}
\subsection{Кластер cassandra}
Кластер запускається на Docker з наступним docker-compose:
\lstinputlisting[
    language=yaml,
    caption={docker-compose.yml},
    label={lst:DC}
]{docker-compose.yml}

\subsection {Частина 1. Робота зі структурами даних у Cassandra}
Для повторюванності виконання запитів до Cassandra, запити виконуються pyton скриптом.
Також, це дозволяє створити генератор даних для таблиць.
Окрім вказаного в завданні функціоналу, скрипт видаляє keyspace, якщо він вже існує.

\lstinputlisting[
    language=python,
    caption={part\_1.py},
]{part_1.py}

Результати тестування:\\
Час роботи: 59.51 секунд\\
Пропускна здатність: 1680.42 запитів/с\\
Кінцеве значення лічильника: 100к



\section{Результати}
\begin{center}
\begin{tabular}{| c | c | c | c |}
    \hline
    Варіант & Час роботи & Пропускна здатність & Значення лічильника \\
    \hline
    1 & 26.37 & 3792.65 & 100к \\
    \hline
    majority & 76.2 & 1312.37 & 100к \\
    \hline
    1 та падіння & 23.05 & 4338.28 & 100к \\
    \hline
    majority та падіння & 59.51 & 1680.42 & 100k \\
    \hline
    
\end{tabular}
\end{center}

\end{document}